// QChan beeper engine port from ZX Spectrum to Arduino
// by Shiru (shiru@mail.ru) 15.02.17

// version for Garvuino https://github.com/farvardin/garvuino
// Works with Arduino IDE 1.8.1
//


//include music data generated by the convert_arduino_octode.py script

//#include "music_data.h"
#include "m_garvalf_vapeurs.h"
//#include "music_data_movie.h"
//#include "m_garvalf_reveries.h"
//#include "m_so_cold_night_c.h"
//#include "m_tufty_fascinated.h"
//#include "m_tufty_1bit_mecha.h"
//#include "m_tufty_robotix.h"

int switchInPin = 2;   



//general settings

#define COMPILE_ADR           40000             //address for compiled Beepola module, default is 40000

//#define SPEAKER_PORT          PORTD             //speaker is on the port D
//#define SPEAKER_DDR           DDRD
//#define SPEAKER_BIT           (1<<7)            //PD7 (Uno pin 7)



// perso
#define SPEAKER_PORT          PORTB             //speaker is on the port b
#define SPEAKER_DDR           DDRB
#define SPEAKER_BIT           (1<<1)            //Pb1 (Uno pin 9)

#define LED 8


#define ENHANCED                                //define to get 5 or ten times higher sample rate compared to the original

#ifndef ENHANCED

#define SAMPLE_RATE           (3500000/404)     //original QChan runs at 8663 Hz, this code allows to set ~7800 to 96000 Hz
#define MUSIC_FRAME           64              	//now many samples in one tempo unit
#define DRUM_DOWNSAMPLE       1                 //for the enhanced mode, to keep drum pitch the same


#else

#define SAMPLE_RATE           (3500000/40)
#define MUSIC_FRAME           64*10
#define DRUM_DOWNSAMPLE       10

#define SAMPLE_RATE           (3500000/80)     //5x rate only
#define MUSIC_FRAME           64*5                //now many samples in one tempo unit
#define DRUM_DOWNSAMPLE       5                 //for the enhanced mode, to keep drum pitch the same

#endif

#define DRUM_LENGTH           64                //duration of a click drum sound
#define DRUM_VOLUME           10                //pulse width for the click drum



//note table, stored in the PROGMEM
//calculated at compile time depending from the sample rate, to make experimenting with it easier
//the magic numbers is the note frequencies of the 8th octave multiplied by 65536

#define NOTE_C(octave)  ((274334351/SAMPLE_RATE)>>(8-octave))
#define NOTEhC(octave)  ((290646917/SAMPLE_RATE)>>(8-octave))
#define NOTE_D(octave)  ((307929415/SAMPLE_RATE)>>(8-octave))
#define NOTEhD(octave)  ((326240174/SAMPLE_RATE)>>(8-octave))
#define NOTE_E(octave)  ((345639485/SAMPLE_RATE)>>(8-octave))
#define NOTE_F(octave)  ((366192230/SAMPLE_RATE)>>(8-octave))
#define NOTEhF(octave)  ((387967221/SAMPLE_RATE)>>(8-octave))
#define NOTE_G(octave)  ((411037204/SAMPLE_RATE)>>(8-octave))
#define NOTEhG(octave)  ((435478855/SAMPLE_RATE)>>(8-octave))
#define NOTE_A(octave)  ((461373440/SAMPLE_RATE)>>(8-octave))
#define NOTEhA(octave)  ((488808120/SAMPLE_RATE)>>(8-octave))
#define NOTE_B(octave)  ((517873991/SAMPLE_RATE)>>(8-octave))

const unsigned int note_table[5*12+2] PROGMEM ={
	0,  //no note
	NOTE_C(1),NOTEhC(1),NOTE_D(1),NOTEhD(1),NOTE_E(1),NOTE_F(1),NOTEhF(1),NOTE_G(1),NOTEhG(1),NOTE_A(1),NOTEhA(1),NOTE_B(1),
	NOTE_C(2),NOTEhC(2),NOTE_D(2),NOTEhD(2),NOTE_E(2),NOTE_F(2),NOTEhF(2),NOTE_G(2),NOTEhG(2),NOTE_A(2),NOTEhA(2),NOTE_B(2),
	NOTE_C(3),NOTEhC(3),NOTE_D(3),NOTEhD(3),NOTE_E(3),NOTE_F(3),NOTEhF(3),NOTE_G(3),NOTEhG(3),NOTE_A(3),NOTEhA(3),NOTE_B(3),
	NOTE_C(4),NOTEhC(4),NOTE_D(4),NOTEhD(4),NOTE_E(4),NOTE_F(4),NOTEhF(4),NOTE_G(4),NOTEhG(4),NOTE_A(4),NOTEhA(4),NOTE_B(4),
	NOTE_C(5),NOTEhC(5),NOTE_D(5),NOTEhD(5),NOTE_E(5),NOTE_F(5),NOTEhF(5),NOTE_G(5),NOTEhG(5),NOTE_A(5),NOTEhA(5),NOTE_B(5),
	0   //key off
};



//array of channel variables, includes accumulator, adder, current volume, volume decay rate, initial volume

unsigned int  acc[4];
unsigned int  add[4];
unsigned char vol[4];

unsigned char decay[4];
unsigned char vol_on[4];

unsigned char pulse_duration;


//click drums variables

unsigned int click_drum_len;
unsigned char click_drum_cnt_1;
unsigned char click_drum_cnt_2;
unsigned char click_drum_downsample;


//sync counter to syncronize the music parser with the synth code
//it is volatile because it the main thread reads it back

volatile unsigned int parser_sync;


//song parser variables

unsigned int song_tempo;

unsigned char *order_list;

unsigned char *pattern_ptr;

unsigned int frame_cnt;
unsigned char decay_cnt;



//initialize all

void setup()
{
   pinMode(switchInPin, INPUT_PULLUP);

	unsigned char chn;

	cli();

	//initialize channel variables

	for(chn=0;chn<4;++chn)
	{
		acc[chn]=0;
		add[chn]=0;
		vol[chn]=0;
		decay[chn]=0;

		vol_on[chn]=pgm_read_byte_near(music_data+chn);
	}

	pulse_duration=0;
	frame_cnt=0;
	decay_cnt=0;

  //initialize click drum variables
  
  click_drum_len=DRUM_LENGTH;
  click_drum_downsample=0;

	//initialize song parser and drum synth variables

	parser_sync=0;
	order_list=music_data+4;

	song_new_pattern();

	//set a port pin as the output

	SPEAKER_DDR|=SPEAKER_BIT; 

	//set timer2 to generate interrupts at the sample rate

	TCCR2A=0;   
	TCCR2B=0;
	TCNT2 =0;

	TCCR2A|=(1<<WGM21);
	TCCR2B|=(0<<CS02)|(1<<CS01)|(0<<CS00);  //prescaler=8
	TIMSK2|=(1<<OCIE2A);

	OCR2A=16000000/8/SAMPLE_RATE;

	sei();
}



ISR(TIMER2_COMPA_vect)
{
	unsigned int n;

  //QChan generates a single pulse of variable width each iteration, this is the easiest way to do it

  if(pulse_duration)
  {
    SPEAKER_PORT|=SPEAKER_BIT;

    delayMicroseconds(pulse_duration);

    SPEAKER_PORT&=~SPEAKER_BIT;

    pulse_duration=0;
  }
    
  //decrement sync variable early, although this isn't that important, no noticeable jitter possible

	if(parser_sync) --parser_sync;

  if(click_drum_len>=DRUM_LENGTH)
  { 
    //update channel adders and calculate next pulse width
    	
  	pulse_duration=0;
  
  	n=acc[0]; acc[0]+=add[0]; if(acc[0]<n) pulse_duration|=vol[0];
  	n=acc[1]; acc[1]+=add[1]; if(acc[1]<n) pulse_duration|=vol[1];
  	n=acc[2]; acc[2]+=add[2]; if(acc[2]<n) pulse_duration|=vol[2];
  	n=acc[3]; acc[3]+=add[3]; if(acc[3]<n) pulse_duration|=vol[3];

  
  	//update volume decay counters
  	
  	++frame_cnt;
  
  	if(frame_cnt>=MUSIC_FRAME)
  	{
  		frame_cnt=0;
  		
  		if(!(decay_cnt&decay[0])) if(vol[0]) --vol[0];
  		if(!(decay_cnt&decay[1])) if(vol[1]) --vol[1];
  		if(!(decay_cnt&decay[2])) if(vol[2]) --vol[2];
  		if(!(decay_cnt&decay[3])) if(vol[3]) --vol[3];
  
  		++decay_cnt;
  	}
  }
  else
  {
      if(click_drum_len>0) {digitalWrite(LED,HIGH);}
      ++click_drum_downsample;

      if(click_drum_downsample>=DRUM_DOWNSAMPLE)
      {
        
        if((click_drum_cnt_1^click_drum_cnt_2)&32) pulse_duration=DRUM_VOLUME;
        
        click_drum_cnt_1=(click_drum_cnt_1+11)^click_drum_cnt_2;
        click_drum_cnt_2=(click_drum_cnt_2+12)^click_drum_cnt_1;
        
        ++click_drum_len;
        
        
  
        click_drum_downsample=0;
       digitalWrite(LED,LOW);
      }
  }
}



void song_new_pattern(void)
{

	unsigned int off;

	while(1)
	{
		off=pgm_read_byte_near(order_list)+(pgm_read_byte_near(order_list+1)<<8);

		order_list+=2;
		
		if(off) break;

		off=pgm_read_byte_near(order_list)+(pgm_read_byte_near(order_list+1)<<8);

		order_list=music_data+(off-COMPILE_ADR);
	}

	pattern_ptr=music_data+(off-COMPILE_ADR);

	song_tempo=pgm_read_byte_near(pattern_ptr)*MUSIC_FRAME;

	decay[0]=pgm_read_byte_near(pattern_ptr+1);
	decay[1]=pgm_read_byte_near(pattern_ptr+2);
	decay[2]=pgm_read_byte_near(pattern_ptr+3);
	decay[3]=pgm_read_byte_near(pattern_ptr+4);

	pattern_ptr+=5;
}



//main loop

void loop()
{
	unsigned char tag,chn,note;
	unsigned int off;

	while(1)
	{
		//update row

		parser_sync=song_tempo;   //earliest point to set up the sync counter

		for(chn=0;chn<4;++chn)
		{
			note=pgm_read_byte_near(pattern_ptr);
			
			++pattern_ptr;

			if(note)
			{
				off=note_table+(note>>1);
				
				add[chn]=pgm_read_byte_near(off)+(pgm_read_byte_near(off+1)<<8);
				vol[chn]=vol_on[chn];
			}
		}

		tag=pgm_read_byte_near(pattern_ptr);

		if(tag>=0x81) //a drum
		{
			tag=(tag-128)<<1;
     
      click_drum_cnt_1=tag;
      click_drum_cnt_2=tag;
      
			click_drum_len=0; 
 
			++pattern_ptr; 
		}

		tag=pgm_read_byte_near(pattern_ptr);
    

		if(tag==0x80) //pattern end
		{
			song_new_pattern();
		}

		//wait for the next row
		//delay 1 is important, by some reason sng tempo starts to jump a lot without it

		while(parser_sync>0) delay(1);
	}
}

 



