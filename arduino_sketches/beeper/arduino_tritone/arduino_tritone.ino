//Tritone beeper engine port from ZX Spectrum to Arduino
//by Shiru (shiru@mail.ru) 17.02.17


//include music data generated by the bin2.py script

//#include "music_data.h"
//#include "music_data_test.h"
#include "music_data_bourrasque.h"
//#include "music_data_incantation.h"
//#include "music_data_misterbeep.h"
//#include "music_data_souvenirs_tritone.h"
//#include "music_data_snakecharmer.h"

//include sample data

#include "drum_sample_data.h"



//general settings

#define COMPILE_ADR           40000             //address for compiled Beepola module, default is 40000

//#define SPEAKER_PORT          PORTD             //speaker is on the port D
//#define SPEAKER_DDR           DDRD
//#define SPEAKER_BIT           (1<<7)            //PD7 (Uno pin 7)


// perso
#define SPEAKER_PORT          PORTB             //speaker is on the port b
#define SPEAKER_DDR           DDRB
#define SPEAKER_BIT           (1<<1)            //Pb1 (Uno pin 9)

#define LED 8


//there is no sample rate, width of the output slots in AVR clocks used instead
//calculated for 22988 Hz sample rate, which is closest to the original Tritone 22875 Hz

#define PULSE_SLOT_1          320
#define PULSE_SLOT_2          224
#define PULSE_SLOT_3          152

#define DRUM_SLOT             ((PULSE_SLOT_1+PULSE_SLOT_2+PULSE_SLOT_3)/2)            //drum samples played at 45977 Hz

#define SAMPLE_RATE           (16000000/(PULSE_SLOT_1+PULSE_SLOT_2+PULSE_SLOT_3))     //just for reference



//array of counters and reload values, for each channel

unsigned int  acc [3];
unsigned int  add [3];
unsigned char out [3];
unsigned char duty[3];



//drum sample player variables

unsigned char drum_output;
unsigned char drum_pulse_length;
unsigned char drum_sync;

const unsigned char *drum_data;



//sync counters to syncronize the music parser with the synth code
//more tricky than other engines because of the original's quirk
//it is volatile because it the main thread reads it back

volatile unsigned char parser_sync_enable;
volatile unsigned char parser_sync_l;
volatile unsigned char parser_sync_h;


//song parser variables

unsigned int song_tempo;

unsigned char *order_list;

unsigned char *pattern_ptr;



//pointer to the actual interrupt handler that gets changed all the time

void (*interrupt_handler)(void);



//initialize all

void setup()
{
	unsigned char chn;

	cli();

	//initialize channel variables

	for(chn=0;chn<3;++chn)
	{
		acc [chn]=0;
		add [chn]=0;
		out [chn]=0;
		duty[chn]=0;
	}

	//initialize song parser variables

	parser_sync_enable=0;
	parser_sync_l=0;
	parser_sync_h=0;

	order_list=music_data;

	song_new_pattern();

	//set a port pin as the output

	SPEAKER_DDR|=SPEAKER_BIT; 

	//set timer2 to generate interrupts at the sample rate

	TCCR2A=0;
	TCCR2B=0;
	TCNT2 =0;

	TCCR2A|=(1<<WGM21);
	TCCR2B|=(0<<CS02)|(1<<CS01)|(0<<CS00);  //prescaler=8
	TIMSK2|=(1<<OCIE2A);

	//force the timer setting and next interrupt handler to start the handler sequence

	interrupt_handler_tone_1();

	sei();
}



//update parser sync counters
//they were made that way in the original to save CPU time

void run_parser_sync(void)
{
	if(parser_sync_enable)
	{
		--parser_sync_l;

		if(!parser_sync_l)
		{
			--parser_sync_h;

			if(!parser_sync_h) parser_sync_enable=0;
		}
	}
}



//first tone slot, for loudest channel

void interrupt_handler_tone_1(void)
{
	OCR2A=PULSE_SLOT_1/8-1;

	SPEAKER_PORT=out[2];

	acc[0]+=add[0]; 
	acc[1]+=add[1];
	acc[2]+=add[2];

	if((acc[0]>>8)>=duty[0]) out[0]=SPEAKER_BIT; else out[0]=0; 
	if((acc[1]>>8)>=duty[1]) out[1]=SPEAKER_BIT; else out[1]=0; 
	if((acc[2]>>8)>=duty[2]) out[2]=SPEAKER_BIT; else out[2]=0; 

	interrupt_handler=interrupt_handler_tone_2; 
}



//second tone slot

void interrupt_handler_tone_2(void)
{
	OCR2A=PULSE_SLOT_2/8-1;

	SPEAKER_PORT=out[1];

	interrupt_handler=interrupt_handler_tone_3;
}



//rhird tone slot, for quietest channel

void interrupt_handler_tone_3(void)
{
	OCR2A=PULSE_SLOT_3/8-1;

	SPEAKER_PORT=out[0];

	run_parser_sync();

	interrupt_handler=interrupt_handler_tone_1;
}



//drum sample player interrupt

void interrupt_handler_drum(void)
{
	OCR2A=DRUM_SLOT/8-1;

	SPEAKER_PORT=drum_output;

	if(drum_pulse_length)
	{
		--drum_pulse_length;
    digitalWrite(LED,HIGH);
	}
	else
	{ 
		drum_output^=SPEAKER_BIT;

		drum_pulse_length=pgm_read_byte_near(drum_data);

		++drum_data;
		
		if(!drum_pulse_length) interrupt_handler=interrupt_handler_tone_1;
	}

	if(drum_sync&1) run_parser_sync();  //drum sample rate is twice higher than tone sample rate, keep sync

	++drum_sync;
}



ISR(TIMER2_COMPA_vect)
{
	interrupt_handler();    //call currently assigned interrupt handler using function pointer
}



void song_new_pattern(void)
{
	unsigned int off;

	while(1)
	{
		off=pgm_read_byte_near(order_list)+(pgm_read_byte_near(order_list+1)<<8);

		order_list+=2;
		
		if(off) break;

		off=pgm_read_byte_near(order_list)+(pgm_read_byte_near(order_list+1)<<8);

		order_list=music_data+(off-COMPILE_ADR);
	}

	pattern_ptr=music_data+(off-COMPILE_ADR);

	song_tempo=pgm_read_byte_near(pattern_ptr)+(pgm_read_byte_near(pattern_ptr+1)<<8);

	pattern_ptr+=2;
}



//main loop

void loop()
{
	unsigned char n,chn;
	unsigned int frq;

	while(1)
	{
		//update row

		while(1)
		{
			n=pgm_read_byte_near(pattern_ptr);

			if(n==0xff) //end of pattern
			{
				song_new_pattern();
				continue;
			}
			
			if(n>=2&&n<128)  //drum sound
			{ 
				drum_data=(const unsigned char*)pgm_read_word(&(drum_sample_list[n-2]));
				
				drum_output=0;
				drum_pulse_length=0;
				drum_sync=0;

				interrupt_handler=interrupt_handler_drum;
				
				++pattern_ptr;
			}

			break;
      
		}

		for(chn=0;chn<3;++chn)
		{
			n=pgm_read_byte_near(pattern_ptr);

			++pattern_ptr;

			if(!n)  //key off
			{
				add [chn]=0;
				duty[chn]=0; 
			}

			if(n>=128)
			{
				frq=(n<<8)+pgm_read_byte_near(pattern_ptr);

				add [chn]=frq&0xfff;
				duty[chn]=(frq>>8)&0xf0;
				
				++pattern_ptr;
			}
		}

		//set up parser sync counters

		parser_sync_l=song_tempo&255;
		parser_sync_h=song_tempo>>8;
		parser_sync_enable=1;

		//wait for the next row
		//delay 1 is important, by some reason song tempo starts to jump a lot without it

	 // while(parser_sync_enable) delay(1);
   while(parser_sync_enable);
   
	}

}
